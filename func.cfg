#!/bin/bash

#----------------------------------------------------------------------------------------------
#
# This function handles failure reports.It sends an issue to Github and rollbacks to previous version
# Issue includes commit number, commit author as asignee and label of failure
#
# Parameters:  Failed commit number       Label of failure ("compile error", "Merging conflict")
#
#-----------------------------------------------------------------------------------------------

function update_failed ()
{
	#Get number of failed commitment and save it in configuration file
         cat /dev/null >../temp_files/update.conf
         echo $1 >>../temp_files/update.conf

        #Send email alert
         #echo  "Update software compilation failed"| mail -s "P$

      #Find out commit's author. Now this is already done while checking signature
      #curl -s -X GET  https://api.github.com/repos/Facj/Repo1/git/commits/$1 > ../json_author.txt 2>&1
      #author=$(cat json_author.txt | jq '.author.name')
      #author=$(awk '/name/' ../json_author.txt |sed -n 1p|awk -F": " '{split($2,a,",");print a[1]}')


    

     #echo "commit author" $author
   
     #Send issue and assign it to the author of the failed commit
       curl -H 'Authorization: token 4ba329d592f0243d946a3d8ca51c0b569c6c0ebc'      -d '{  
          "title": "commit '"$1"'",  
          "body": "'"$2"''"$3"'",  
           "assignee": "'"$author"'",
           "labels": ["'"$2"'","bug"]  
         }'      https://api.github.com/repos/Facj/Repo1/issues > ../temp_files/error.log 2>&1


	  #Rollback to previous version
        git reset --hard ORIG_HEAD >/dev/null 2>&1
}


#----------------------------------------------------------------------------------------------
#
# This function handles security problems reports.It sends an issue to Github.
# Issue includes commit number and label of security problem. No asignee is provided.
#
# Parameters:  Unsafe commit number       Label of failure ("compile error", "Merging conflict")
#
#-----------------------------------------------------------------------------------------------

function security_problem ()
{
	#Get number of unsafe commitment and save it in configuration file
         cat /dev/null >../temp_files/update.conf
         echo $1 >>../temp_files/update.conf

   
     #Send issue and assign it to the author of the failed commit
       curl -H 'Authorization: token 4ba329d592f0243d946a3d8ca51c0b569c6c0ebc'      -d '{  
          "title": "commit '"$1"'",  
          "body": "'"$2"'",  
           "labels": ["'"$2"'","security"]  
         }'      https://api.github.com/repos/Facj/Repo1/issues > ../temp_files/error.log 2>&1

}



#----------------------------------------------------------------------------------------------
#
# This function compiles the update files if they are C source files.
# If not successful it calls the function update_failed and returns 1. 
#
# Parameters: commit_number
#
#-----------------------------------------------------------------------------------------------

function compile_update()
{               

    y=0
    #Check if updated files are C source files
    for x in "${changed_files[@]}"; do
        arr=$(echo $x | awk -F'.' '{print ""$2}') 
        if [ "$arr" == "c" ]
        then
            exec=$(echo $x | awk -F'.' '{print ""$1}')
            echo "Compile" $x
	    gcc $x -o $exec  >/dev/null 2>&1
	    if [ $? -ne 0 ]
	    then
		echo "loop compile failed"
		update_failed $1 "Compilation error"  " in $x"

		return 1
            else
                cat /dev/null >../temp_files/update.conf   #Successful update
                compiled_files[$y]=$exec
             ((y++))
	    fi
	    
	fi 
    done
    return 0
}


#----------------------------------------------------------------------------------------------
#
# This function checks what files have been updated and saves them in the array changed_files
#
# Parameters: commit_number
#
#-----------------------------------------------------------------------------------------------

function check_changed_files()
{
       x=0
         changed=$(git whatchanged $1 -1 --pretty=oneline)
         #echo $changed_files
         read -r line  <<< "$changed"  #First line is ignored
          
        while read -r line;do
         if [ $x -ne 0 ]
           then
	     arr=$(echo $line | awk -F'M ' '{print ""$2}') 
             changed_files[$x]=$arr
            #echo ${changed_files[$x]}
	 fi 
         
        ((x++))

         done <<< "$changed" 
}

#-----------------------------------------------------------------------------------------------------------
#
# This function checks it there are new commitments in the repository that have not been proved wrong before.
# If variable received is true it calls the function that checks if commits have been tagged and signed
# If new commits availale returns 0.
#
# Parameters: key_check
#
#------------------------------------------------------------------------------------------------------------

function check_available_update(){

     #Check if there are new commits
    git fetch origin >/dev/null 2>&1
   
   if $1; then
        check_available_signed_update
        return $?   
  else

   cherry_out=$(git cherry master origin)
    #echo "result from cherry:" $cherry_out
    
    if [ "$cherry_out" != "" ]
    then  
        #Check last commit id
	cherry_out=$(git cherry master origin)
	while read -r line;do
            last_line=$line
	done <<< "$cherry_out" 
	new_v=${last_line:2:40}
  
       #Check if this commitment has been proved wrong before
	old_v=$(head -n 1 ../temp_files/update.conf)
	
	if [ "$old_v" == "" ] || [ "$new_v" != "$old_v" ] 
	then   
            return 0     
	else
	    return 1
	fi  
    else
	return 1
	
    fi
fi
}



#-----------------------------------------------------------------------------------------------------------
#
# This function checks it there are new commitments in the repository that haven been tagged, signed by trusted
# source and not proved wrong before.
# If new trusted commits available returns 0.
#
# Parameters: no parameters
#
#------------------------------------------------------------------------------------------------------------

function check_available_signed_update(){
typeset lines;
old_v=$(head -n 1 ../temp_files/update.conf)

git describe --abbrev=0 >/dev/null 2>&1
if [ $? -eq 0 ]
then
	current_tag=$(git describe --abbrev=0) 
fi

x=0

echo $current_tag
        #Check last commit id
    cherry_out=$(git cherry master origin)
    while read -r line;do
        lines[x]=$line
         x=$((x+1))
    done <<< "$cherry_out" 

  if [ "$cherry_out" != "" ]
     then
    element=${#lines[@]} ;
    
    for x in "${lines[@]}"; do
	element=$((element-1));
	new_v=${lines[element]:2:40}
	#echo $element  $new_v

       #Check if this commitment has been proved wrong before
       #If yes, not correct updates available
       #If not, check the tag
	
	if [ "$old_v" == "" ] || [ "$new_v" != "$old_v" ] 
	then   
	    
	    new_tag=$(git describe $new_v --abbrev=0) </dev/null 2>&1
	   
	    if [ "$current_tag" == "$new_tag" ]
	    then
		echo "Not a new tag.Not updating" $new_tag
                return 1;
	    else
		echo "New tag" $new_tag
		
		commit_tag=$(git describe $new_v)
		if [ "$new_tag" == "$commit_tag" ]
		then
		    echo "This commit is a new tag.Verify"
		    
		    git verify-tag $new_tag >../temp_files/verified_signature.txt 2>&1   
		    if [ $? -ne 0 ]
		    then
			echo "Not signed or untrusted signature"   #Signature doesn't exist or is not in our keyring
			security_problem $new_v "Not signed or untrusted signature" 
		    else
			echo "Trusted signature"   #Signature in our keyring 
           		check_signature_holder $new_v
            		if [ $? -eq 0 ]
        		 then
           			return 0
   
            		else
                 		security_problem $new_v "Signature theft" 
             		fi                     
		    fi
		    
		else
		    echo "This commit is not tagged. Search for the tag commit"
		    
		    
		fi
	    fi
	 	    
         else
	    return 1
	fi  
        
    done
    
fi
return 1
      
}



#-----------------------------------------------------------------------------------------------------------
#
# This function checks who is the owner of the signature provided in the tag that is being check.
# If it matches the author of the tag commit it returns 0.
# If not it returns 1
#
# Parameters: no parameters
#
#------------------------------------------------------------------------------------------------------------

function check_signature_holder(){

   check_update_author $new_v
   
    
   #check_author's email
   author_email=$(findGitHubEmail $author)

  #Check signature holder
   holder=$(grep -Eio '[a-z0-9._-]+@[a-z0-9.-]+[a-z]{2,4}' ../temp_files/verified_signature.txt)
   
  #Compare checking the email address
 	if [ "$holder" == "$author_email" ]
	 then
     	     echo "Signature correct"
             return 0
        else
	    echo -e "Signature theft.\nSigned by "$holder"\nAuthored by "$author_email
            return 1
	fi

}

#-----------------------------------------------------------------------------------------------------------
#
# This function sends HTTP request through GitHub API to find out who is the author of the update
# Parameters: no parameters
#
#------------------------------------------------------------------------------------------------------------

function check_update_author(){

	#Find out commit's author
	curl -s -X GET  https://api.github.com/repos/Facj/Repo1/git/commits/$new_v > ../temp_files/json_author.txt 2>&1
	#author=$(cat json_author.txt | jq '.author.name')
	author=$(awk '/name/' ../temp_files/json_author.txt |sed -n 1p|awk -F": " '{split($2,a,",");print a[1]}')
        author=$(echo $author | tr -d '"')   #Remove character "" from author string     
}




#-----------------------------------------------------------------------------------------------------------
#
# This function checks if the update compiled files are current running processes and changes them for updated
#processes.
#
# Parameters: No parameters
#
#------------------------------------------------------------------------------------------------------------
function change_running_version(){

     for x in "${compiled_files[@]}"; do
	 prid=$(pidof $x)
	 case "$prid" in
             [0-9]*) echo "$x running"
		 kill $prid
		 ./$x &;;
             *) echo "$x not running";;
	 esac
     done
}

#-----------------------------------------------------------------------------------------------------------
#
# This function changes the frequency of update checking by modifying the crontab entry.
# Frequency can be given in minutes(m), hours(h) or days(d)
#
# Parameters: m/d/h frequency_value
#
#------------------------------------------------------------------------------------------------------------
function change_frequency(){

   #Remove previous crontab entry
    crontab -l | grep -v update.sh |crontab
   
   if [ $2 -eq 0 ]  #If the value received is 0 automatic updates are disabled
   then
        echo "Automatic update check  disabled"
   	return
   fi
   #Create new crontab entry
    case $1 in
	m) var="*/$2 * * * *";;
	h) var="0 */$2 * * *";;
	d) var="0 0 */$2 * *";;
    esac
    #echo "$var  bash /home/pi/git/update.sh >>/home/pi/git/update_record.txt"
    
   #Write entry to crontab
    {	crontab -l
	echo "$var  bash /home/pi/git/update.sh >>/home/pi/git/update_record.txt"
    } | (sleep 1; crontab -)
    
   echo "Crontab updated"
}

#-----------------------------------------------------------------------------------------------------------
#
# This function checks email of the given GitHub user
#
# Parameters: GitHub_user_name
#
#------------------------------------------------------------------------------------------------------------

# FindGitHubEmail (https://github.com/hodgesmr/FindGitHubEmail)
# Copyright (c) 2013 Matt Hodges (http://matthodges.com)
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

function findGitHubEmail(){ 
USER=$1
PROFILERESPONSE=`curl -s https://api.github.com/users/$USER`
EMAIL=`echo "$PROFILERESPONSE" | grep "\"email\":" | sed -e's/[,|"]//g' | awk '{print $(NF)}' | grep -v null`

if [ -z "$EMAIL" ] ; then
  
  EVENTRESPONSE=`curl -s https://api.github.com/users/$USER/events/public`
  EMAIL=`echo "$EVENTRESPONSE" | grep "\"email\":" | sed -e's/[,|"]//g' | sort | uniq -c | sort -n | awk '{print $(NF)}' | grep -v null | tail -n1`
fi

if [ -n "$EMAIL" ] ; then
  echo "$EMAIL"
fi
}





